# 进程调度
**IO消耗型**：进程的大部分时间用来提交IO请求或等待IO请求。

**处理器消耗型**：进程把大多数时间用在执行代码上。

时间片表明进程在被抢占前所能持续运行的时间，时间片的划分与该进程是属于IO消耗型还是处理器消耗型密不可分，Linux中使用CFS调度器，它没有直接分配时间片到进程，它是将处理器的使用比划分给了进程，它的抢占时机取决于新的可运行程序消耗了多少处理器使用比，处理器使用比与进程优先级有关，如果消耗的使用比比当前进程小，则新进程将进行抢占。

CFS调度器的示例：假如系统中同时具有文字编辑程序以及视频编码程序，这两个进程拥有同样的nice值，那么处理器的使用比都将是50%，当文本编辑程序被唤醒时，CFS注意到虽然它的使用比为50%，但实际使用却非常少，为了所有进程公平分享处理器的承诺，会让它立刻抢占视频解码程序，让文本编辑程序投入运行。

## Linux调度算法
Linux调度器是以模块方式提供的，目的是允许不同类型的进程可以有针对性的选择调度算法。模块化结构被称为调度器类，它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。

完全公平调度(CFS)是针对普通进程的调度类，在Linux中称为`SCHED_NORMAL`.

传统的调度算法会分配绝对的时间片进而引发固定的切换频率，给公平性造成了很大的变数，CFS则对时间片分配方式进行根本性的重新设计，完全摒弃时间片而分配给进程一个处理器使用比重，确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动中。
## 公平调度
完美的多任务处理器模型应该是这样的，能在10ms内同时运行两个进程，它们各自使用处理器一半的能力，而不是先运行其中一个5s，再运行另一个5s，它们任何一个运行时都将占有100%的处理器。

CFS调度算法不依靠nice值计算时间片，而是在所有可运行进程总数基础上计算出一个进程应该运行多久，nice值被作为进程获得的处理器运行比的权重。任何进程所获的的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的。
## Linux调度的实现
### 时间记账
调度器需要对进程运行时间做记账。

CFS使用调度器实体结构`sched_entity`来追踪进程进行记账，它作为一个成员变量，嵌入在进程描述符`struct task_struct`中。其中的`vruntime`用来存放进程的虚拟运行时间，
### 进程选择
CFS根据`vruntime`的值来选择下一个运行进程，会选择具有最小`vruntime`的任务进行，采用红黑树来组织可运行进程队列，以迅速找到最小`vruntime`的进程。