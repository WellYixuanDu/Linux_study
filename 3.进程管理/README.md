# 进程管理
## 进程
进程是处于执行期的程序，但进程不仅仅局限于一段可执行程序代码，通常进程还包括打开的文件描述符，挂起的信号，处理器状态等其他资源。内核需要有效而又透明地管理所有细节。

线程是在进程中活动的对象，每个线程都拥有一个独立的程序计数器，进程栈和一组进程寄存器，对于Linux系统而言，线程和进程的实现并不区分。

于进程而言，存在两种虚拟机制，分别是虚拟处理器和虚拟内存，但于同一个进程中的线程而言，可以共享虚拟内存，但每个线程都拥有各自的虚拟处理器。
***
## 进程描述符及任务结构
### 进程描述符
内核把进程的列表存放在名为任务队列的双向循环链表中，链表中的每一项均为结构体`task_struct` 称为进程描述符,存放在`<linux.sched.h>`文件中。

`struct thread_info` 用于存储与体系结构相关的部分信息，其中包含 `task_struct` 的指针。`struct thread_info` 的定义如下所示。
```c
struct thread_info
{
    struct task_struct *task;
    struct exec_domain *exec_domain;
    __u32 flags;
    ...
};
```
在内核中，访问任务通常需要获得指向其`task_struct`的指针，因此，获取当前正在运行进程的进程描述符的速度就显得尤为重要。不同处理器获取该结构的方式也不尽相同，其中，IBM基于RISC的现代微处理器中，由于寄存器数量较多，因此，采用一个专门的寄存器来存放进程描述符的地址，而在x86中，则是通过计算相对应的偏移量来完成的。
```c
union thread_union {
	struct thread_info thread_info;
	unsigned long stack[THREAD_SIZE/sizeof(long)];
};
```
其中，`thread_info` 即我们上文提到的结构，`stack`则为进程内核栈，在每一个进程的生命周期中，经常会通过系统调用`SYSCALL`陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先用户空间中的栈，而是一个内核空间的栈，这个称作进程的“内核栈”。

在linux内核中，进程内核栈和`thread_info`结构是通过一个`union`进行定义的，也就是共享同一个地址空间。

因此，当我们获得当前进程内核栈sp寄存器存储的地址时，我们根据`THREAD_SIZE` 进行字节对齐便可以得到`thread_info`的基地址,假定栈的大小为8KB，那么 `current_thread_info()` 函数则如下所示
```c
movl $-8192 %eax
andl %esp, %eax
```
---
### 进程状态
进程处于下列五种状态之一

* TASK_RUNNING(运行) 进程是可执行的或正在运行，它是进程在用户空间中唯一可能的状态。
* TASK_INTERRUPTIBLE(可中断) 进程被阻塞，等待某些条件的达成来变为可运行或运行状态。
* TASK_UNINTERRUPTIBLE(不可中断) 处于该状态的任务对信号不做响应
* __TASK_TRACED 被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。
* __TASK_STOPPED(停止)，进程停止执行

内核可以通过`set_task_state(task, state)` 函数来设置某个进程的状态。
### 进程家族树
Linux系统中所有的进程都是PID为1的`init`进程的后代，进程间的关系存放在进程描述符中，每个`task_struct`都包含一个指向其父进程叫做parent的指针，还包含一个称为children的子进程链表。
## 进程创建
Unix 将进程的创建步骤分为两个不同的函数进行，分别是`fork()`和`exec()`，`fork()`函数拷贝当前进程并创建一个子进程，子进程与父进程的区别在于PID,PPID,和某些资源和统计量比如挂起的信号，`exec()`函数负责读取可执行文件并将其载入地址空间开始运行。

Linux采用写时拷贝的技术来提高效率，`fork()`的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。

Linux通过`clone()`系统调用实现`fork()`函数，`clone()`函数通过调用`do_fork()`来完成相应的工作，它定义在`kernel/fork.c`文件中，调用`copy_process()`函数让进程开始运行，完成工作如下:

* 调用`dup_task_struct()` 为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。
* 检查并确保新创建的这个子进程后，当前用户所拥有的进程数目没有超过给它分配的资源的限制。
* 子进程着手将自己与父进程区别开来，将进程描述符中的成员进行初值的设置。
* 子进程的状态设置为`TASK_UNINTERRUPTIBLE` ，保证它不回投入运行
* 调用`copy_flags()`更新`task_struct`的`flags`成员，
* 调用`alloc_pid()`为新进程分配一个有效的PID
* 根据传递给`clone()`的参数标志，`copy_process()`拷贝或者共享打开的文件、信号处理函数等。
* 进行扫尾工作，并返回一个指向子进程的指针。

回到`do_fork()`函数之后，如果成功返回，新创建的子进程被唤醒并让他投入运行，内核虽然有意让子进程首先执行，因为一般子进程会马上调用`exec()`函数可以避免写时拷贝的额外开销，如果父进程首先执行的话，可能会向地址空间写入，但并非总能让子进程首先执行。
### 线程在Linux中的实现
每个线程拥有自己的`task_struct`因此，在内核中，它看起来就像是一个普通的进程。

线程的创建和普通进程的创建类似，只不过在调用`clone()`的时候需要传递一些参数标志来指明需要共享的资源:
```c
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
```
父子俩共享地址空间，文件系统资源，文件描述符和信号处理程序。

### 内核线程
内核线程用于内核在后台完成一些操作，内核线程和普通的进程的区别在于内核线程没有独立的地址空间，即mm指针被设置为`NULL`，它们只在内核空间运行，不会切换到用户空间。
从现有内核线程中创建新的内核线程的方法为通过`kthread_run`宏定义调用 `kthread_create`方法。
## 进程终结
当一个进程终结时，内核必须释放它所占有的资源并通知其父进程。

进程的析构发生在调用`exit()`系统调用时，依靠`do_exit()`来完成进程的终结。

* 将`task_struct`的标志成员设置为`PF_EXITING`
* 调用`del_timer_sync()`删除任一内核定时器，根据返回的结果确保没有定时器在排队，也没有定时器处理程序在运行
* 如果BSD的进程记账功能开启，调用`acct_update_integrals`输出记账信息
* 调用`exit_mm()`函数释放进程占用的`mm_struct`，如果该地址没有被共享，就释放它们。
* 调用`sem__exit()函数，如果进程排队等候IPC信号，它则离开队列。
* 调用`exit_files()`和`exit_fs()`来递减引用计数。
* 把存放在`task_struct`的`exit_code`成员中的任务退出代码置为exit()提供的退出代码，或者其他退出动作，以供父进程随时检索。
* 调用`exit_notify`向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或init进程，并把进程状态设为 `EXIT_ZOMBIE`
* 调用`schedule()`切换到新的进程，`do_exit()`永不返回。

至此，进程所占有的内存便为内核栈，thread_info以及task_struct结构
  
### 删除进程描述符
`do_exit()` 被调用之后，线程已经僵死不能运行，但进程描述符还仍被保留，以给父进程提供信息，父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的`task_struct`才被释放。

`release_task()` 被用来释放进程描述符

* 调用`exit__signal()`，该函数调用`__unhash_process()`，后者又调用`detach_pid()`从`pdihash`上删除该进程，同时也要从任务列表中删除该进程。
* `__exit_signal()`释放目前僵死进程所使用的所有剩余资源,并进程最终统计和记录。
* 如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么`release_task()`就要通知僵死的领头进程的父进程。
* `release_task()`调用`put_task_struct`释放进程内核栈和`thread_info`结构所占的页，并释放`task_struct`所占的`slab`高速缓存。

### 孤儿进程
如果父进程在子进程之前退出，必须为子进程找到一个父进程，否则子进程退出后将会成为僵死状态，浪费内存，解决方法是给子进程在当前线程组内找一个线程作为父亲，或者让init作为他们的父进程。


